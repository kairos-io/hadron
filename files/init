#!/bin/sh

VERSION=1.0.0
INIT=/sbin/init
sysroot="$ROOT"/sysroot
# This is where we mount the livecd
liveroot=/run/initramfs/live
# This is where we mount the root squash file
rootfsbase=/run/rootfsbase
# This is the base dir for the overlay, it needs to be RW
rootRW=/run/overlay
# This is the name of the rootfs squash that comes in the livecd/netboot
rootfssquash=rootfs.squashfs

# some helpers
ebegin() {
	last_emsg="$*"
	echo "$last_emsg..." > "$ROOT"/dev/kmsg
	echo -n " * $last_emsg: "
}

eend() {
  local rc="${1:-$?}"
  shift 2>/dev/null || true
  if [ "$rc" -eq 0 ]; then
    echo "$last_emsg: ok." > "$ROOT"/dev/kmsg
    echo "ok."
  else
    echo "$last_emsg: failed. $*" > "$ROOT"/dev/kmsg
    echo "failed. $*"
    drop_shell
  fi
}

# same as eend but this wont drop us to a shell and continue booting
eend_no_break() {
  local rc="${1:-$?}"
  shift 2>/dev/null || true
  if [ "$rc" -eq 0 ]; then
    echo "$last_emsg: ok." > "$ROOT"/dev/kmsg
    echo "ok."
  else
    echo "$last_emsg: failed. $*" > "$ROOT"/dev/kmsg
    echo "failed. $*"
  fi
}

# find mount dir and mount opts for given device in an fstab
get_fstab_mount_info() {
	local search_dev="$1"
	local fstab="$2"
	local mntopts=
	case "$search_dev" in
	UUID*|LABEL*) search_dev=$(findfs "$search_dev");;
	esac
	[ -r "$fstab" ] || return 1
	local search_maj_min=$(stat -L -c '%t,%T' $search_dev)
	while read dev mnt fs mntopts chk; do
		case "$dev" in
		UUID*|LABEL*) dev=$(findfs "$dev");;
		esac
		if [ -b "$dev" ] || [ -n "$ROOT" ]; then
			local maj_min=$(stat -L -c '%t,%T' $dev)
			if [ "$maj_min" = "$search_maj_min" ]; then
				echo "$mnt $mntopts"
				return
			fi
		fi
	done < $fstab
}

# relocate mountpoint according given fstab and set mount options
remount_fstab_entry() {
	local fstab="${1}"
	local dir=
	if ! [ -e "$repofile" ]; then
		return
	fi
	cat - "$repofile" | while read dir; do
		# skip http(s)/ftp repos for netboot
		if [ -z "$dir" ] || ! [ -d "$ROOT/$dir" -o -f "$ROOT/$dir" ]; then
			continue
		fi
		local dev=$(df -P "$dir" | tail -1 | awk '{print $1}')
		local mntinfo="$(get_fstab_mount_info "$dev" "$fstab")"
		local mnt="${mntinfo% *}"
		local mntopts="${mntinfo#* }"
		if [ -n "$mnt" ]; then
			local oldmnt=$(awk -v d=$ROOT$dev '$1==d {print $2}' "$ROOT"/proc/mounts 2>/dev/null)
			if [ "$oldmnt" != "$mnt" ]; then
				mkdir -p "$mnt"
				mount -o move "$oldmnt" "$mnt"
			fi
			if [ -n "$mntopts" ]; then
				mount -o remount,"$mntopts" "$mnt"
			fi
		fi
	done
}

rtc_exists() {
	local rtc=
	for rtc in /dev/rtc /dev/rtc[0-9]*; do
		[ -e "$rtc" ] && break
	done
	[ -e "$rtc" ]
}

# support for udev
udev_start()
{

	if [ -e /proc/sys/kernel/hotplug ]; then
		echo "" >/proc/sys/kernel/hotplug
	fi
  ebegin "Start udev"
  /usr/lib/systemd/systemd-udevd --daemon
  udevadm hwdb --update

  # Populating /dev with existing devices through uevents
  udevadm trigger --type=subsystems --action=add
  udevadm trigger --type=devices --action=add
  udevadm settle --timeout=8 || true
  eend $?
}

# retry function
retry() {
  retries=$1
  shift

  count=0
  until "$@"; do
    exit=$?
    wait=$((count + 1))
    count=$((count + 1))
    if [ "$count" -lt "$retries" ]; then
      echo "Retry $count/$retries exited $exit, retrying in $wait seconds..."
      sleep $wait
    else
      echo "Retry $count/$retries exited $exit, no more retries left."
      return $exit
    fi
  done
}

# Make sure PATH sees udevadm, helpers, etc.
export PATH="/usr/bin:/bin:/usr/sbin:/sbin"

# ---------------- NET DEBUG HARNESS ----------------
NET_DEBUG=1  # set 0 to reduce noise
log() {
  echo "initnet: $*"            # console
  echo "initnet: $*" > /dev/kmsg
}

dump_ifaces() {
  for p in /sys/class/net/*; do
    [ -d "$p" ] || continue
    n="${p##*/}"; [ "$n" = lo ] && continue
    drv=$(basename "$(readlink -f "$p"/device/driver 2>/dev/null)" 2>/dev/null)
    car=$(cat "$p"/carrier 2>/dev/null || echo -)
    op=$(cat "$p"/operstate 2>/dev/null || echo -)
    ip4=$(ip -4 addr show dev "$n" 2>/dev/null | awk '/inet /{print $2}' | xargs)
    mac=$(cat "$p"/address 2>/dev/null || echo -)
    log "iface $n: driver=$drv mac=$mac carrier=$car oper=$op ip4=$ip4"
  done
}

# detect udev binaries explicitly (your path)
_detect_udev_bins() {
  UDEV_BIN=""
  UDEVADM=""
  for p in /usr/lib/systemd/systemd-udevd /lib/systemd/systemd-udevd \
           /usr/lib/udev/udevd /sbin/udevd /bin/udevd /usr/sbin/udevd; do
    [ -x "$p" ] && UDEV_BIN="$p" && break
  done
  if command -v udevadm >/dev/null 2>&1; then
    UDEVADM="$(command -v udevadm)"
  else
    for p in /usr/bin/udevadm /bin/udevadm /sbin/udevadm; do
      [ -x "$p" ] && UDEVADM="$p" && break
    done
  fi
}

predict_final_ifname() {
  # ask udev what the final name would be for a legacy eth*
  _detect_udev_bins
  local ifc="$1"
  [ -n "$UDEVADM" ] || { echo "$ifc"; return; }
  "$UDEVADM" test-builtin net_id "/sys/class/net/$ifc" 2>/dev/null |
    awk -F= '/ID_NET_NAME_(PATH|SLOT|ONBOARD|MAC)=/{print $2; exit}'
}

_wait_iface_node() {
  local ifc="$1" t=0 max="${2:-10}"
  while [ $t -lt "$max" ]; do
    [ -d "/sys/class/net/$ifc" ] && return 0
    sleep 1; t=$((t+1))
  done
  return 1
}

_net_candidates() {
  # Prefer en*, else predict names for eth*, else eth*
  out=""
  for p in /sys/class/net/en*; do
    [ -d "$p" ] || continue
    n="${p##*/}"; [ "$n" = lo ] && continue
    out="$out $n"
  done
  if [ -z "$out" ]; then
    for p in /sys/class/net/eth*; do
      [ -d "$p" ] || continue
      n="${p##*/}"; [ "$n" = lo ] && continue
      pred="$(predict_final_ifname "$n")"
      [ -n "$pred" ] && out="$out $pred"
    done
  fi
  if [ -z "$out" ]; then
    for p in /sys/class/net/eth*; do
      [ -d "$p" ] || continue
      n="${p##*/}"; [ "$n" = lo ] && continue
      out="$out $n"
    done
  fi
  echo "$out" | xargs -n1 | awk '!seen[$0]++' | xargs
}

# ---- public entry: try DHCP on all, return on first success
# Usage: net_try_all_dhcp  [carrier_wait_sec] [tries] [timeout_between_tries]
net_try_all_dhcp() {
  local wait_carrier="${1:-8}" tries="${2:-3}" timeout="${3:-3}"

  # If still no NICs, poll a bit for them to appear
  tries_scan=0
  ifaces=""
  while [ $tries_scan -lt 12 ]; do
    ifaces="$(_net_candidates)"
    [ -n "$ifaces" ] && break
    sleep 0.5
    tries_scan=$((tries_scan+1))
  done
  if [ -z "$ifaces" ]; then
    log "no NICs found after settle"
    return 1
  fi
  log "candidates: $ifaces"

  for i in $ifaces; do
    # wait for the final name node (covers last-moment renames)
    _wait_iface_node "$i" 10 || { log "$i not present yet, skipping"; continue; }

    log "bringing up $i"
    ip link set "$i" up 2>/dev/null

    # wait for carrier/operstate briefly
    t=0
    while [ $t -lt "$wait_carrier" ]; do
      [ "$(cat /sys/class/net/$i/carrier 2>/dev/null)" = "1" ] && break
      [ "$(cat /sys/class/net/$i/operstate 2>/dev/null)" = "up" ] && break
      sleep 1; t=$((t+1))
    done
    [ "$NET_DEBUG" = 1 ] && dump_ifaces

    log "DHCP on $i"
    ip -4 addr flush dev "$i" 2>/dev/null
    # keep it synchronous; exit 0 only when we have a lease
    udhcpc -i "$i" -q -n -t "$tries" -T "$timeout"
    rc=$?

    if [ $rc -eq 0 ]; then
      export NET_IFACE="$i"
      mkdir -p /run 2>/dev/null || true
      echo "$i" > /run/net.iface 2>/dev/null || true
      log "DHCP SUCCESS on $i"
      return 0
    else
      log "DHCP failed on $i (rc=$rc)"
    fi
  done

  log "No DHCP lease on: $ifaces"
  return 1
}
# -------------- END NET DEBUG HARNESS --------------



is_url() {
	case "$1" in
	http://*|https://*|ftp://*)
		return 0;;
	*)
		return 1;;
	esac
}

pick_console() {
  for tok in $(cat /proc/cmdline); do
    case "$tok" in
      console=*) dev=${tok#console=}; dev=${dev%,*}; echo "$dev"; return;;
    esac
  done
  echo ttyS0
}

drop_shell() {
  TTY="$(pick_console)"
  # If it's a serial TTY and node missing, create classic major/minor for ttyS0
  [ -c "/dev/$TTY" ] || { [ "$TTY" = ttyS0 ] && mknod -m 600 /dev/ttyS0 c 4 64 || true; }

  echo "spawning interactive shell on $TTY (BusyBox getty)"
  export PS1='(initramfs) \u@\h:\w# '
  while true; do
    # -L local line, -n no login prompt, -l /bin/sh exec shell directly
    /sbin/getty -L -n -l /bin/sh 115200 "$TTY" vt100
    echo "getty on $TTY exited ($?) â€” respawning"
    sleep 1
  done
}

rd_break() {
  if grep -q "rd.break=$1" /proc/cmdline; then
    echo "initramfs emergency recovery shell launched" > "$ROOT"/dev/kmsg
    echo "initramfs emergency recovery shell launched"
    drop_shell
  fi
}


/bin/busybox mkdir -p "$ROOT"/usr/bin \
	"$ROOT"/usr/sbin \
	"$ROOT"/proc \
	"$ROOT"/sys \
	"$ROOT"/dev \
	"$sysroot" \
	"$ROOT"/media/cdrom \
	"$ROOT"/media/usb \
	"$ROOT"/tmp \
	"$ROOT"/etc \
	"$ROOT"/var/lock \
	"$ROOT"/run/lock \
	"$ROOT"/run/cryptsetup

# Spread out busybox symlinks and make them available without full path
/bin/busybox --install -s
export PATH="$PATH:/usr/bin:/bin:/usr/sbin:/sbin"

mount -t sysfs -o noexec,nosuid,nodev sysfs /sys
mount -t devtmpfs -o exec,nosuid,mode=0755,size=2M devtmpfs /dev 2>/dev/null \
	|| mount -t tmpfs -o exec,nosuid,mode=0755,size=2M tmpfs /dev

# Make sure /dev/null is a device node. If /dev/null does not exist yet, the command
# mounting the devtmpfs will create it implicitly as an file with the "2>" redirection.
# The -c check is required to deal with initramfs with pre-seeded device nodes without
# error message.
[ -c /dev/null ] || mknod -m 666 /dev/null c 1 3

# Make sure /dev/kmsg is a device node. Writing to /dev/kmsg allows the use of the
# earlyprintk kernel option to monitor early files progress. As above, the -c check
# prevents an error if the device node has already been seeded.
[ -c /dev/kmsg ] || mknod -m 660 /dev/kmsg c 1 11

mount -t proc -o noexec,nosuid,nodev proc /proc
# pty device nodes (later system will need it)
[ -c /dev/ptmx ] || mknod -m 666 /dev/ptmx c 5 2
[ -d /dev/pts ] || mkdir -m 755 /dev/pts
mount -t devpts -o gid=5,mode=0620,noexec,nosuid devpts /dev/pts

# shared memory area (later system will need it)
[ -d /dev/shm ] || mkdir /dev/shm
mount -t tmpfs -o nodev,nosuid,noexec shm /dev/shm

# mount run
mount -t tmpfs -o nodev,nosuid,noexec,rw tmpfs /run

echo "UKairos Init $VERSION" > "$ROOT"/dev/kmsg
echo "Ukairos Init $VERSION"

# pick first keymap if found
for map in "$ROOT"/etc/keymap/*; do
	if [ -f "$map" ]; then
		ebegin "Setting keymap ${map##*/}"
		zcat "$map" | loadkmap
		eend
		break
	fi
done


rd_break pre-udev
# persistent device names from udev in order for immucore to mount stuff
udev_start
rd_break post-udev

rd_break pre-network
if grep -vq "rd.neednet=0" /proc/cmdline; then
  ebegin "Networking: try all NICs for DHCP"
  if net_try_all_dhcp 8 3 3; then
    eend 0
  else
    eend_no_break 1 "no lease"
  fi
fi
rd_break post-network

# Path for booting from netboot
if grep -q netboot /proc/cmdline; then
  echo "Netbooting"
  rd_break pre-netboot

  for x in $(cat /proc/cmdline); do
    # shellcheck disable=SC2039
    [[ $x = root=live:* ]] || continue
    root=${x#root=live:}
  done

  if ! is_url "$root";then
    echo "$root is not a valid url, cannot continue"
    echo "initramfs emergency recovery shell launched"
    exec /bin/busybox sh
  fi
  sync
  # Create mountpoints
  ebegin "Create mountpoints"
  mkdir -p $rootRW $rootfsbase $sysroot$rootRW $sysroot$rootfsbase
  eend $?

  ebegin "Download rootfs"
  wget -q "$root" -O /tmp/$rootfssquash
  eend $?

  # Mount squashfs into loop device
  ebegin "Mount rootfs as squashfs device"
  retry 5 losetup /dev/loop0 /tmp/$rootfssquash
  eend $?
  sync
  rd_break post-netboot
fi

# Path for booting from livecd
if grep -q cdroot /proc/cmdline ;then
  rd_break pre-livecd
  echo "Mounting Live Media"
  sync
  label=$(grep -o CDLABEL.* /proc/cmdline | cut -f 1 -d ' ' | cut -f 2 -d '=' )
  # Create mountpoints
  ebegin "Create mountpoints"
  mkdir -p $liveroot $rootRW $rootfsbase $sysroot$liveroot $sysroot$rootRW $sysroot$rootfsbase
  eend $?
  # Between udev starting, we loading the modules and the cdrom appearing sometimes there is a delay, so lets wait a bit here
  ebegin "Waiting for Live Media to be available"
  retry 10 test -e /dev/disk/by-label/$label
  eend
  # Mount read-only livecd
  ebegin "Mount Live Media RO"
  retry 10 mount /dev/disk/by-label/$label $liveroot
  eend $?
  sync
  # Mount squashfs into loop device
  ebegin "Mount rootfs as squashfs device"
  retry 5 losetup /dev/loop0 $liveroot/$rootfssquash
  eend $?
  sync
  rd_break post-livecd
fi

# shared path for netboot and livecd, we expect the rootfs to be already in /dev/loop0
if grep -q cdroot /proc/cmdline || grep -q netboot /proc/cmdline;then
    rd_break pre-mounts
    # Mount loop device into the rootfsbase
    ebegin "Mount loop device into rootfsbase"
    retry 5 mount /dev/loop0 $rootfsbase
    eend $?
    sync
    # Mount writable overlay tmpfs
    ebegin "Mount base overlay"
    mount -t tmpfs -o "mode=0755,rw,size=25%" root-tmpfs $rootRW
    eend $?
    sync
    # Create additional mountpoints and do the overlay mount
    mkdir -p $rootRW/work $rootRW/root
    ebegin "Mount rootfs overlay into sysroot"
    mount -t overlay -o lowerdir=$rootfsbase,upperdir=$rootRW/root,workdir=$rootRW/work overlayfs $sysroot
    eend $?
    sync
    rd_break pre-immucore
  	# immucore to run the initramfs and rootfs stages
    ebegin "Run immucore"
    immucore
    eend $?
    rd_break post-immucore
    # Move current mounts into sysroot mounts

    mkdir -p "$sysroot"/{proc,sys,dev,run}
    mount --move /proc "$sysroot/proc"
    mount --move /sys  "$sysroot/sys"
    mount --move /dev  "$sysroot/dev"
    mount --move /run  "$sysroot/run"
    rd_break post-mounts
    # stop udevd, will be relaunched by openrc
    udevadm control --exit

    # hide kernel messages from now on
    dmesg -n 1

  	# shellcheck disable=SC2093
  	exec switch_root "$sysroot" "$INIT"
  	echo "initramfs emergency recovery shell launched"
  	exec /bin/busybox sh
fi

rd_break pre-immucore
# Path for booting active/passive/recovery
ebegin "Run immucore"
immucore
eend $?

rd_break post-immucore

# TODO: Use this at the start to set an aprox time for the initramfs?
# use swclock if no RTC is found
if rtc_exists || [ "$(uname -m)" = "s390x" ]; then
	rc_add hwclock boot
else
	rc_add swclock boot
fi


rd_break pre-binds
# Mount bind system mounts to sysroot to keep them going
mkdir -p "$sysroot"/{proc,sys,dev,run}

mount --move /proc "$sysroot/proc"
mount --move /sys  "$sysroot/sys"
mount --move /dev  "$sysroot/dev"
mount --move /run  "$sysroot/run"
rd_break post-binds

# remount according default fstab from package
if [ -z "$has_fstab" ] && [ -f "$sysroot"/etc/fstab ]; then
	remount_fstab_entry "$sysroot"/etc/fstab
fi


! [ -f "$sysroot"/etc/resolv.conf ] && [ -f /etc/resolv.conf ] && \
	cp /etc/resolv.conf "$sysroot"/etc

if [ ! -x "${sysroot}${INIT}" ]; then
	echo "$INIT not found in new root. Launching emergency recovery shell"
	echo "Type exit to continue boot."
	/bin/busybox sh
fi

rd_break pre-switch

# hide kernel messages from now on
dmesg -n 1
# switch over to new root
echo ""
# shellcheck disable=SC2093
exec switch_root "$sysroot" "$INIT"

# If it fails, drop to recovery shell
echo "initramfs emergency recovery shell launched"
# shellcheck disable=SC2093
exec /bin/busybox sh
reboot